import os
import sys
import json
import time
import asyncio
import logging
import threading
import hashlib
import requests
import numpy as np
import pandas as pd
import tensorflow as tf
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor
from tenacity import retry, stop_after_attempt, wait_exponential
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout, Input
from dotenv import load_dotenv
import pyupbit
from openai import OpenAI
import ta
import telegram
from telegram import Bot
from filelock import FileLock
from ta.volatility import BollingerBands, AverageTrueRange
from ta.momentum import RSIIndicator
from ta.trend import MACD, EMAIndicator, ADXIndicator

# API í‚¤ ì„¤ì •
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
UPBIT_ACCESS_KEY = os.getenv("UPBIT_ACCESS_KEY")
UPBIT_SECRET_KEY = os.getenv("UPBIT_SECRET_KEY")

logger.info("API í‚¤ í™•ì¸ ì¤‘...")
missing_keys = []
for key, value in [
    ("TELEGRAM_TOKEN", TELEGRAM_TOKEN),
    ("TELEGRAM_CHAT_ID", TELEGRAM_CHAT_ID),
    ("OPENAI_API_KEY", OPENAI_API_KEY),
    ("UPBIT_ACCESS_KEY", UPBIT_ACCESS_KEY),
    ("UPBIT_SECRET_KEY", UPBIT_SECRET_KEY)
]:
    if not value:
        missing_keys.append(key)
if missing_keys:
    logger.error(f"ëˆ„ë½ëœ API í‚¤: {', '.join(missing_keys)}")
    raise ValueError("í™˜ê²½ ë³€ìˆ˜ íŒŒì¼(.env)ì— í•˜ë‚˜ ì´ìƒì˜ API í‚¤ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.")

@cache_result(expiry_seconds=CACHE_EXPIRY_SECONDS['default'])
def get_fear_and_greed():
    if not rate_limiter.can_make_api_call():
        time.sleep(0.1)
        return get_fear_and_greed()
    try:
        response = requests.get("https://api.alternative.me/fng/", timeout=10)
        response.raise_for_status()
        data = response.json()
        logger.info("ê³µí¬ì™€ íƒìš• ì§€ìˆ˜ ê°€ì ¸ì˜¤ê¸° ì„±ê³µ")
        return int(data['data'][0]['value'])
    except Exception as e:
        logger.error(f"ê³µí¬ì™€ íƒìš• ì§€ìˆ˜ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: {e}")
        return 50

class MarketAnalyzer:
    def __init__(self):
        os.makedirs("lstm_models", exist_ok=True)
        self.client = OpenAI(api_key=OPENAI_API_KEY)
        self.scaler = MinMaxScaler(feature_range=(0, 1))
        self.model = self._build_lstm_model()
        logger.info("ì‹œì¥ ë¶„ì„ê¸° ì´ˆê¸°í™” ì™„ë£Œ")

    def _build_lstm_model(self):
        model = Sequential([
            Input(shape=(60, 1)),
            LSTM(100, return_sequences=True),
            Dropout(0.3),
            LSTM(100),
            Dropout(0.3),
            Dense(1)
        ])
        model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001), loss='mse')
        logger.info("LSTM ëª¨ë¸ ìƒì„± ì™„ë£Œ")
        return model

class TradingBot:
    def __init__(self, dca_ratio=DCA_RATIO):
        self.trading_history = TradingHistory()
        self.stop_loss_manager = StopLossManager()
        self.market_analyzer = MarketAnalyzer()
        self.purchased_coins = FileManager.load_json(COINS_FILE, {"coins": [], "last_analysis": {}})
        self.last_opportunity_scan = 0
        self.opportunities = []
        self.buy_ratios = {
            'BTC': 0.5,
            'ETH': 0.5,
            'ALT': 0.4,
            'HIGH_CONFIDENCE': 0.7
        }
        self.dca_ratio = dca_ratio
        self.last_portfolio_error_time = 0
        self.sync_with_upbit_account()
        logger.info("íŠ¸ë ˆì´ë”© ë´‡ ì´ˆê¸°í™” ì™„ë£Œ")

if executed_amount > 0 and order_info["state"] == "done":
                    executed_price = optimal_price
                    await self.trading_history.add_trade(ticker, "buy", executed_price, executed_amount, reason)
                    total_amount = position["amount"] + executed_amount
                    total_cost = (position["amount"] * position["entry_price"]) + (executed_amount * executed_price)
                    new_avg_price = total_cost / total_amount if total_amount > 0 else executed_price
                    self.stop_loss_manager.update_position(ticker, new_avg_price=new_avg_price, amount=total_amount)
                    logger.info(f"{ticker} ì¶”ê°€ ë§¤ìˆ˜ ì™„ë£Œ: ê°€ê²©={executed_price:,.2f}ì›, ìˆ˜ëŸ‰={executed_amount:.8f}ê°œ")
                    message = (
                        f"ğŸ”¥ ì¶”ê°€ ë§¤ìˆ˜ ì‹¤í–‰: {ticker}\n"
                        f"ê°€ê²©: {executed_price:,.2f}ì›\n"
                        f"ìˆ˜ëŸ‰: {executed_amount:.8f}ê°œ\n"
                        f"ì´ ê¸ˆì•¡: {executed_amount * executed_price:,.0f}ì›\n"
                        f"ì‚¬ìœ : {reason}"
                    )

async def log_portfolio_status(self):
        try:
            krw_balance = upbit.get_balance("KRW") or 0
            total_value = float(krw_balance)
            total_invested = 0
            portfolio_message = (
                f"ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ ìƒíƒœ ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')})\n"
                f"ğŸ’° KRW ì”ê³ : {krw_balance:,.2f}ì›\n"
                f"ğŸ“‹ ë³´ìœ  ì½”ì¸:\n"
            )

try:
                        coin_data = {
                            "ticker": ticker,
                            "current_price": float(current_price),
                            "entry_price": float(entry_price),
                            "profit_percent": float(profit_percent),
                            "predicted_price": float(predicted_price) if predicted_price else None,
                            "market_risk_level": risk_level,
                            "sell_ratio": float(sell_ratio)
                        }
                        response = self.market_analyzer.client.chat.completions.create(
                            model="gpt-4",
                            messages=[
                                {
                                    "role": "system",
                                    "content": """xxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                                    ì˜ˆ: "ìˆ˜ìµë¥  10% ë‹¬ì„± ë° ì‹œì¥ í•˜ë½ ì˜ˆì¸¡". ë°˜ë“œì‹œ 50ì ì´ë‚´ë¡œ ìœ ì§€í•˜ì„¸ìš”."""
                                },
                                {
                                    "role": "user",
                                    "content": json.dumps(coin_data, default=serialize_numpy)
                                }
                            ]
                        )
                        reason = response.choices[0].message.content.strip()

if __name__ == "__main__":
    import os
    from dotenv import load_dotenv

    load_dotenv()
    CYCLE_INTERVAL = int(os.getenv("CYCLE_INTERVAL", 14400))
    
    logger.info("íŠ¸ë ˆì´ë”© ë´‡ ì‹œì‘...")
    try:
        asyncio.run(TradingBot.async_run_bot(cycle_interval=CYCLE_INTERVAL))
    except KeyboardInterrupt:
        logger.info("ì‚¬ìš©ìì— ì˜í•œ ì¢…ë£Œ ìš”ì²­. í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì¤‘...")
        # ë¹„ë™ê¸° ì‘ì—… ì •ë¦¬
        async def shutdown():
            tasks = [task for task in asyncio.all_tasks() if task is not asyncio.current_task()]
            for task in tasks:
                task.cancel()
            await asyncio.gather(*tasks, return_exceptions=True)
            await async_send_telegram_message("ğŸš¨ í”„ë¡œê·¸ë¨ì´ ì‚¬ìš©ìì— ì˜í•´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
